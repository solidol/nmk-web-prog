# Лекція 11. Об'єктно-орієнтоване програмування ч.2

[Перелік лекцій](../README.md)

## Модифікатори доступу

Модифікатори доступу - це, по суті, інтерпретація інкапсуляції в ООП. Нагадую, що інкапсуляція - це механізм приховування реалізації об'єкта. І для реалізації інкапсуляції існують модифікатори доступу в PHP.

У PHP є три модифікатори доступу:

1.  Public
2.  Protected
3.  Private

Почнемо з модифікаторів доступу **public.** Даний модифікатор означає, що властивість, метод або конструктор будуть доступні для всіх об'єктів, які їх використовують.

Модифікатор доступу **protected** означає, що даний елемент об'єкта може бути використаний в самому об'єкті, а також у його дочірніх.

І, нарешті, модифікатор доступу **private** означає, що даний елемент об'єкта може бути використаний тільки в самому об'єкті і ніде більше.

## Область видимості властивостей

Властивості класу повинні бути визначені через модифікатори public, private, або protected.

**Приклад 1**. Оголошення властивості класу


```php
<?php
/* 
Визначення MyClass 
*/
class MyClass
{
    public $public = "Загальний";
    protected $protected = "Захищений";
    private $private = "Закритий";

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // Працює
echo $obj->protected; // Невиправна помилка
echo $obj->private; // Невиправна помилка
$obj->printHello(); // Виводить Загальний, Захищений і Закритий

/* 
Визначення MyClass2 
*/
class MyClass2 extends MyClass
{
    // Ми можемо перевизначити public і protected методи, але не private
    protected $protected = "Захищений2";

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj2 = new MyClass2();
echo $obj2->public; // Працює
echo $obj2->private; // Невизначений
echo $obj2->protected; // Невиправна помилка
$obj2->printHello(); // Виводить Загальний, Захищений2 і Закритий
?>
```


**Зауваження**: Метод оголошення змінної через ключове слово var, прийнятий в PHP 4, досі підтримується з метою сумісності (як синонім ключового слова public). У версіях PHP 5 нижче 5.1.3 таке використання виводить попередження E_STRICT.

## Область видимості методу

Методи класу повинні бути визначені через модифікатори public, private, або protected. Методи, де визначення модифікатора відсутня, визначаються як public.

**Приклад 2** Оголошення методу


```php
<?php
/* 
Визначення MyClass 
*/
class MyClass
{
    // Оголошення загальнодоступного конструктора
    public function __construct()
    {
    }

    // Оголошення загальнодоступного методу
    public function MyPublic()
    {
    }

    // Оголошення захищеного методу
    protected function MyProtected()
    {
    }

    // Оголошення закритого методу
    private function MyPrivate()
    {
    }

    // Це загальнодоступний метод
    function Foo()
    {
        $this->MyPublic();
        $this->MyProtected();
        $this->MyPrivate();
    }
}

$myclass = new MyClass();
$myclass->MyPublic(); // Працює
$myclass->MyProtected(); // Помилка
$myclass->MyPrivate(); // Помилка
$myclass->Foo(); // Працює загальний, захищений і закритий

/* 
Визначення MyClass2 
*/
class MyClass2 extends MyClass
{
    // Це загальнодоступний метод
    function Foo2()
    {
        $this->MyPublic();
        $this->MyProtected();
        $this->MyPrivate(); // Невиправна помилка
    }
}

$myclass2 = new MyClass2();
$myclass2->MyPublic(); // Працює
$myclass2->Foo2(); // Працює загальний і захищений, закритий не працює

class Bar
{
    public function test()
    {
        $this->testPrivate();
        $this->testPublic();
    }

    public function testPublic()
    {
        echo "Bar::testPublic \n";
    }

    private function testPrivate()
    {
        echo "Bar::testPrivate \n";
    }
}

class Foo extends Bar
{
    public function testPublic()
    {
        echo "Foo::testPublic \n";
    }

    private function testPrivate()
    {
        echo "Foo::testPrivate \n";
    }
}

$myFoo = new foo();
$myFoo->test(); // Bar::testPrivate
?>
```


## Статичні методи і властивості

Статичні методи класу можуть бути викликані безпосередньо у класі, а не через один із його об'єктів. Відповідно, покажчик $this в статичних методах недоступний.

Фактично, оголошення класу зі статичними методами є, більшою мірою, методом угруповання функцій і загальних для них констант і змінних.

Застосування такого підходу гарантує, що всі класи доступу до бази даних будуть реалізовувати один інтерфейс, зменшується вірогідність конфліктності імен, спрощується існування декількох версій класу доступу до бази і т.д.


```php
<?php
class MyClass
{
    static function helloWorld()
    {
        print "Hello, world";
    }
}
MyClass::helloWorld();
?>
```


Загальне використання статичних методів показано на прикладі:


```php
<?php
class Singleton
{
    private static $instance = null;

    private function __construct()
    {
    }

    public static function getInstance()
    {
        if (self::$instance == null) {
            self::$instance = new Singleton();
        }
        return self::$instance;
    }
}
?>
```


## Подвійна двокрапка

Використовуючи цю лексему, програміст може звертатися до констант, статичних або перевантажених властивостей або методів класу.

При зверненні до цих елементів ззовні класу, програміст повинен використовувати ім'я цього класу.

**Приклад 1** Використання ::поза оголошення класу


```php
<?php
class MyClass
{
    const CONST_VALUE = "Значення константи";
}
echo MyClass::CONST_VALUE;
?>

```


Для звернення до властивостей і методів в оголошенні класу використовуються ключові слова self і parent.

**Приклад 2** Використання ::в оголошенні класу


```php
<?php
class OtherClass extends MyClass
{
    public static $my_static = "статична змінна";

    public static function doubleColon()
    {
        echo parent::CONST_VALUE . "\n";
        echo self::$my_static . "\n";
    }
}

OtherClass::doubleColon();
?>

```


Коли дочірній клас перевантажує методи, оголошені в класі-батьку, PHP не буде здійснювати автоматичний виклик методів, що належать класу-батькові. Цей функціонал покладається на метод, перевантаження в дочірньому класі. Це правило поширюється на конструктори і деструктори, перевантажені та методи.

**Приклад 3** Звернення до методу в батьківському класі


```php
<?php
class MyClass
{
    protected function myFunc()
    {
        echo "MyClass::myFunc () \n";
    }
}

class OtherClass extends MyClass
{
    /* Перезапис батьківського визначення */
    public function myFunc()
    {
        /* Але виклик батьківської функції все-рівно відбувається */
        parent::myFunc();
        echo "OtherClass::myFunc () \n";
    }
}

$Class = new OtherClass();
$Class->myFunc();
?>
```


## Оператор instanceof

Підтримка перевірки залежності від інших об'єктів. Функцією is_a (), яка міститься в PHP 4, користуватися тепер не рекомендується.


```php
<?php 
if ($obj instance of Circle) { 
print '$obj is a Circle'; 
}
?>
```


## Фінальні методи і класи

### Метод final

Ключове слово final дозволяє вам позначати методи, щоб наслідуючий клас не міг перевантажити їх. Розмістивши перед оголошенням методів або властивостей класу ключове слово final, ви можете запобігти їх перевизначення в дочірніх класах, наприклад:


```php
<?php
class BaseClass
{
    public function test()
    {
        echo "Викликаний метод BaseClass::test () \n";
    }

    final public function moreTesting()
    {
        echo "Викликаний метод BaseClass::moreTesting () \n";
    }
}

class ChildClass extends BaseClass
{
    public function moreTesting()
    {
        echo "Викликаний метод ChildClass::moreTesting () \n";
    }
}
// Виконання закінчується фатальною помилкою:
// Неможливо перезаписати фінальний метод BaseClass::moreTesting ()
// (Метод BaseClass::moretesting () не може бути перевизначений)
?>

```


## Класи, помічені як final

Після оголошення класу final він не може бути успадкований. Наступний приклад викличе помилку:


```php
<?php
final class FinalClass
{
}

class BogusClass extends FinalClass
{
}
?>

```


## Абстрактні класи та методи

### Абстрактні класи

PHP 5 підтримує визначення абстрактних класів і методів. Створювати екземпляр класу, який був оголошений абстрактним, не можна. Клас, в якому оголошено хоча б один абстрактний метод, повинен також бути оголошений абстрактним. Методи, оголошені як абстрактні, несуть, по суті, лише описовий зміст і не можуть включати будь-який функціонал. Клас може бути оголошений як абстрактний за допомогою використання ключового слова abstract, для виключення з обробки. Однак, ви можете наслідувати абстрактні класи. Практичний приклад:


```php
<?php
abstract class AbstractClass
{
    /* Даний метод повинен бути визначений в дочірньому класі */
    abstract protected function getValue();
    /* Загальний метод */
    public function print()
    {
        print $this->getValue();
    }
}
class ConcreteClass1 extends AbstractClass
{
    protected function getValue()
    {
        return "ConcreteClass1";
    }
}
class ConcreteClass2 extends AbstractClass
{
    protected function getValue()
    {
        return "ConcreteClass2";
    }
}
$Class1 = new ConcreteClass1();
$Class1->print();
$Class2 = new ConcreteClass2();
$Class2->print();
?>
```


### Абстрактні методи

Метод може бути оголошений як abstract, таким чином відклавши його визначення спадкоємним класом. Клас, який включає абстрактні методи, повинен бути оголошений як abstract.


```php
<?php 
abstract class MyBaseClass { 
    abstract function display (); 
}
?>
```


У PHP 5 з'явилася така чудова можливість ООП, як інтерфейс класів. Інтерфейс визначає методи, які повинен містити клас. Всі методи, визначені у інтерфейсі повинні бути реалізовані. Інтерфейс створюється за допомогою ключового слова interface. Всі методи в інтерфейсі повинні бути публічними.
```php
interface CanWalk { 
    public function walk (); 
}
```

Клас може реалізовувати декілька інтерфейсів. Перерахування інтерфейсів виконується після ключового слова implements:
```php
class Bird implements walk, run, fly
{
    public function walk()
    {
        echo "Walk!";
    }
    public function run()
    {
        echo "Run!";
    }
    public function fly()
    {
        echo "Fly!";
    }
}
```
**Інтерфейс** - це семантична і синтаксична конструкція в коді програми, яка використовується для послуг, що надаються класом чи компонентом. Інтерфейс визначає межу взаємодії між класами або компонентами, специфікуючи певну абстракцію, яку здійснює сторона. На відміну від багатьох інших видів інтерфейсів, інтерфейс в ООП є строго формалізованим елементом об'єктно-орієнтованої мови і широко використовується кодом програми.

Таким чином, з одного боку, **інтерфейс** \- це контракт, який зобов'язується виконати клас, який реалізує його, з іншого боку, **інтерфейс** - це тип даних, тому що його опис досить чітко визначає властивості об'єктів, щоб нарівні з класом типізувати змінні. Слід, однак, підкреслити, що інтерфейс не є повноцінним типом даних, так як він задає тільки зовнішню поведінку об'єктів. Внутрішню структуру і реалізацію заданого інтерфейсом поведінку забезпечує клас, який реалізує інтерфейс; саме тому «прикладів інтерфейсу» в чистому вигляді не буває, і будь-яка змінна типу «інтерфейс» містить екземпляри конкретних класів.

## Інтерфейси та абстрактні класи

Можна помітити, що інтерфейс, з точки зору реалізації - це просто чистий абстрактний клас, тобто клас, в якому не визначено нічого, крім абстрактних методів. Якщо мова програмування підтримує множинне успадкування і абстрактні методи (як, наприклад, C + +), то необхідність у введенні в синтаксис мови, окремого поняття «інтерфейс» не виникає. Дані сутності описуються за допомогою абстрактних класів і успадковуються класами для реалізації абстрактних методів.

Однак підтримка множинного спадкоємства в повному обсязі досить складна і викликає безліч проблем, як на рівні реалізації мови, так і на рівні архітектури додатків. Введення поняття інтерфейсів є компромісом, що дозволяє отримати багато переваг множинного спадкування (зокрема, можливість зручно визначати логічно пов'язані набори методів у вигляді сутностей, подібних класам, допускати спадкування і реалізацію), не реалізовуючи його в повному обсязі і не стикаючись, таким чином, з більшістю викликаних ним труднощів.


## Спадкування 

Наслідування є одним із основних аспектів об'єктно-орієнтованого програмування. Наслідування дозволяє класу використовувати функціонал вже наявних класів і за потреби перевизначати його. Якщо у нас є якийсь клас, у якому не вистачає кількох функцій, то набагато простіше перевизначити існуючий клас, написавши кілька рядків, ніж створювати новий з нуля, переписуючи велику кількість коду.

Щоб наслідувати один клас від іншого, потрібно застосувати оператор `extends`. Варто зазначити, що в PHP можна наслідувати клас тільки від одного класу. Множинне наслідування не підтримується.

Наприклад, наслідуємо клас Employee від класу Person:

```php
<?php
class Person
{ 
    public $name;
    function __construct($name)
    {
        $this->name = $name;
    }
    function displayInfo()
    {
        echo "Ім'я: $this->name<br>";
    }
}
class Employee extends Person 
{}
 
$tom = new Employee("Tom");
$tom -> displayInfo();
?>
```

У цьому випадку припустимо, що клас Person представляє людину загалом, а клас Employee — працівника певного підприємства. Відповідно, кожен працівник є людиною. І щоб не дублювати один і той самий функціонал, краще в цьому випадку наслідувати клас працівника — Employee від класу людини — Person. У цій парі клас Person називається батьківським або базовим класом, а клас Employee — похідним або класом-нащадком.

І оскільки клас Employee наслідується від Person, для об'єктів класу Employee ми можемо використовувати функціонал батьківського класу Person. Так, для створення об'єкта Employee у цьому випадку викликається конструктор, який визначено в класі Person і який приймає параметр із ім'ям людини:

```php
$tom = new Employee("Tom");
```

Також у змінної типу Employee викликається метод `displayInfo`, який визначено в класі Person:

```php
$tom -> displayInfo();
```

### Перевизначення функціоналу

Унаслідувавши функціонал від батьківського класу, клас-нащадок може додати свої властивості та методи або перевизначити наявний функціонал. Наприклад, змінимо клас Employee, додавши до нього дані про компанію, у якій працює працівник:

```php
<?php
class Person
{ 
    public $name;
    function __construct($name)
    {
        $this->name = $name;
    }
    function displayInfo()
    {
        echo "Ім'я: $this->name<br>";
    }
}
class Employee extends Person 
{
    public $company;
    function __construct($name, $company)
    {
        $this->name = $name;
        $this->company = $company;
    }
    function displayInfo()
    {
        echo "Ім'я: $this->name<br>";
        echo "Працює в $this->company<br>";
    }
}
 
$tom = new Employee("Tom", "Microsoft");
$tom -> displayInfo();
?>
```

Тут клас Employee додає нову властивість — `$company`, яка зберігає компанію працівника. Також клас Employee перевизначив конструктор, до якого передаються дані для імені та компанії. Крім того, перевизначено метод `displayInfo()`. Відповідно, для створення об'єкта класу Employee тепер необхідно використовувати перевизначений у класі Employee конструктор:

```php
$tom = new Employee("Tom", "Microsoft");
```

Клас-нащадок перевизначає конструктор батьківського класу, тому для створення об'єкта класу-нащадка потрібно використовувати перевизначений у ньому конструктор.

Також зміниться поведінка методу `displayInfo()`, який тепер, крім імені, виведе і компанію працівника:

```
Ім'я: Tom
Працює в Microsoft
```

### Виклик функціоналу батьківського класу

Якщо ми подивимося на код класу-нащадка Employee, то побачимо частини коду, які повторюють код класу Person. Наприклад, встановлення імені в конструкторі:

```php
$this->name = $name;
```

Або виведення імені працівника в методі `displayInfo()`:

```php
echo "Ім'я: $this->name<br>";
```

У таких випадках доцільніше не писати повторюваний код у класі-нащадку, а викликати відповідний функціонал батьківського класу за допомогою ключового слова `parent`. Наприклад, перепишемо попередній приклад:

```php
<?php
class Person
{ 
    public $name;
    function __construct($name)
    {
        $this->name = $name;
    }
    function displayInfo()
    {
        echo "Ім'я: $this->name<br>";
    }
}
class Employee extends Person 
{
    public $company;
    function __construct($name, $company)
    {
        parent::__construct($name);
        $this->company = $company;
    }
    function displayInfo()
    {
        parent::displayInfo();
        echo "Працює в $this->company<br>";
    }
}
 
$tom = new Employee("Tom", "Microsoft");
$tom -> displayInfo();
?>
```

Тепер у конструкторі Employee викликається конструктор базового класу:

```php
parent::__construct($name);
```

Так само, у методі `displayInfo()` викликається реалізація методу класу Person:

```php
parent::displayInfo();
```

У результаті ми отримаємо той самий результат.
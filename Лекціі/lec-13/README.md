# Лекція 13. Наслідування

[Перелік лекцій](../README.md)

Наслідування є одним із основних аспектів об'єктно-орієнтованого програмування. Наслідування дозволяє класу використовувати функціонал вже наявних класів і за потреби перевизначати його. Якщо у нас є якийсь клас, у якому не вистачає кількох функцій, то набагато простіше перевизначити існуючий клас, написавши кілька рядків, ніж створювати новий з нуля, переписуючи велику кількість коду.

Щоб наслідувати один клас від іншого, потрібно застосувати оператор `extends`. Варто зазначити, що в PHP можна наслідувати клас тільки від одного класу. Множинне наслідування не підтримується.

Наприклад, наслідуємо клас Employee від класу Person:

```php
<?php
class Person
{ 
    public $name;
    function __construct($name)
    {
        $this->name = $name;
    }
    function displayInfo()
    {
        echo "Ім'я: $this->name<br>";
    }
}
class Employee extends Person 
{}
 
$tom = new Employee("Tom");
$tom -> displayInfo();
?>
```

У цьому випадку припустимо, що клас Person представляє людину загалом, а клас Employee — працівника певного підприємства. Відповідно, кожен працівник є людиною. І щоб не дублювати один і той самий функціонал, краще в цьому випадку наслідувати клас працівника — Employee від класу людини — Person. У цій парі клас Person називається батьківським або базовим класом, а клас Employee — похідним або класом-нащадком.

І оскільки клас Employee наслідується від Person, для об'єктів класу Employee ми можемо використовувати функціонал батьківського класу Person. Так, для створення об'єкта Employee у цьому випадку викликається конструктор, який визначено в класі Person і який приймає параметр із ім'ям людини:

```php
$tom = new Employee("Tom");
```

Також у змінної типу Employee викликається метод `displayInfo`, який визначено в класі Person:

```php
$tom -> displayInfo();
```

### Перевизначення функціоналу

Унаслідувавши функціонал від батьківського класу, клас-нащадок може додати свої властивості та методи або перевизначити наявний функціонал. Наприклад, змінимо клас Employee, додавши до нього дані про компанію, у якій працює працівник:

```php
<?php
class Person
{ 
    public $name;
    function __construct($name)
    {
        $this->name = $name;
    }
    function displayInfo()
    {
        echo "Ім'я: $this->name<br>";
    }
}
class Employee extends Person 
{
    public $company;
    function __construct($name, $company)
    {
        $this->name = $name;
        $this->company = $company;
    }
    function displayInfo()
    {
        echo "Ім'я: $this->name<br>";
        echo "Працює в $this->company<br>";
    }
}
 
$tom = new Employee("Tom", "Microsoft");
$tom -> displayInfo();
?>
```

Тут клас Employee додає нову властивість — `$company`, яка зберігає компанію працівника. Також клас Employee перевизначив конструктор, до якого передаються дані для імені та компанії. Крім того, перевизначено метод `displayInfo()`. Відповідно, для створення об'єкта класу Employee тепер необхідно використовувати перевизначений у класі Employee конструктор:

```php
$tom = new Employee("Tom", "Microsoft");
```

Клас-нащадок перевизначає конструктор батьківського класу, тому для створення об'єкта класу-нащадка потрібно використовувати перевизначений у ньому конструктор.

Також зміниться поведінка методу `displayInfo()`, який тепер, крім імені, виведе і компанію працівника:

```
Ім'я: Tom
Працює в Microsoft
```

### Виклик функціоналу батьківського класу

Якщо ми подивимося на код класу-нащадка Employee, то побачимо частини коду, які повторюють код класу Person. Наприклад, встановлення імені в конструкторі:

```php
$this->name = $name;
```

Або виведення імені працівника в методі `displayInfo()`:

```php
echo "Ім'я: $this->name<br>";
```

У таких випадках доцільніше не писати повторюваний код у класі-нащадку, а викликати відповідний функціонал батьківського класу за допомогою ключового слова `parent`. Наприклад, перепишемо попередній приклад:

```php
<?php
class Person
{ 
    public $name;
    function __construct($name)
    {
        $this->name = $name;
    }
    function displayInfo()
    {
        echo "Ім'я: $this->name<br>";
    }
}
class Employee extends Person 
{
    public $company;
    function __construct($name, $company)
    {
        parent::__construct($name);
        $this->company = $company;
    }
    function displayInfo()
    {
        parent::displayInfo();
        echo "Працює в $this->company<br>";
    }
}
 
$tom = new Employee("Tom", "Microsoft");
$tom -> displayInfo();
?>
```

Тепер у конструкторі Employee викликається конструктор базового класу:

```php
parent::__construct($name);
```

Так само, у методі `displayInfo()` викликається реалізація методу класу Person:

```php
parent::displayInfo();
```

У результаті ми отримаємо той самий результат.
# Лекція 13. Маршрутизація (Роутінг)

[Перелік лекцій](../README.md)

## Узагальнено

Маршрутизація є одним із ключових механізмів сучасних програмних систем, особливо у веб-застосунках, де вона визначає, як саме зовнішні запити потрапляють до внутрішньої логіки програми. З погляду архітектури, маршрутизація слугує “навігаційною картою”, яка задає відповідність між тим, що запитує користувач, і тим, як система повинна на це реагувати. У багатьох фреймворках вона є невидимим рушієм, який керує потоком даних і забезпечує впорядкованість процесів.

Перш ніж розглядати деталі, варто зрозуміти базовий принцип. У веб-контексті кожен запит, який надходить до сервера, містить адресний шлях, тип операції та додаткові параметри. Маршрутизатор аналізує ці дані та визначає, який саме фрагмент коду повинен бути виконаний. У класичних MVC-системах маршрутизація найчастіше спрямовує запит до певного методу контролера. Наприклад, якщо користувач відкриває адресу зі списком товарів, маршрутизатор “знає”, що це запит, який має обробляти контролер товарів, і саме він повинен повернути потрібні дані або представлення. Таким чином, маршрутація виступає сполучною ланкою між зовнішнім світом і внутрішньою логікою.

Цікаво, що маршрутизація виникла не як побічний елемент, а як відповідь на необхідність впорядкувати обробку численних запитів у зростаючих системах. У ранніх веб-застосунках кожна сторінка могла існувати як окремий файл на сервері, і сервер просто повертав його користувачу. Але з часом застосунки стали динамічними, а їхні сторінки перестали існувати як статичні файли. Потрібен був механізм, який дозволяє визначати логіку не за фізичними файлами, а за правилами. Саме маршрутизація дала можливість працювати з “віртуальними шляхами”, які не мають фізичного відповідника, але які сервер може інтерпретувати й передавати програмі для обробки.

У сучасних системах маршрутизація формується як набір правил. Кожне правило описує шлях, структуру параметрів і метод запиту, який очікується. Деякі маршрутизатори використовують шаблони або регулярні вирази, інші — декларативні таблиці відповідностей. Наприклад, адреса може містити змінні частини, такі як ідентифікатор користувача. У цьому випадку маршрутизатор повинен не просто знайти відповідний маршрут, а й “витягнути” змінні зі шляху та передати їх у контролер. Саме тому маршрутизація відіграє роль не лише в навігації, а й у первинній обробці даних, форматуванні параметрів і встановленні контексту для подальших дій.

Важливою частиною маршрутизації є визначення пріоритетів. У великих системах із великою кількістю шляхів можуть траплятися ситуації, коли кілька маршрутів формально підходять під один і той самий запит. Тому маршрутизатор повинен точно знати, у якому порядку перевіряти маршрути. Найчастіше пріоритет мають більш конкретні правила, а “широкі”, універсальні маршрути перевіряються останніми. Це запобігає несподіваним конфліктам і забезпечує передбачуваність.

Не менш важливою є можливість групувати маршрути. У великих застосунках часто використовується поділ на модулі, і кожен модуль має власний набір маршрутів. Наприклад, маршрути, пов’язані з користувачами, можуть починатися з одного префікса, а маршрути для продуктів — з іншого. Таке групування не лише робить структуру чистішою, а й дозволяє застосовувати спільні правила, такі як авторизація, логування або перевірка прав доступу. Маршрутизація в цьому випадку вступає в тісну взаємодію з middleware-компонентами та механізмами безпеки.

Варто згадати й про роль маршрутизації у фронтенд-застосунках, особливо односторінкових (SPA). Тут маршрутизація виконується не на сервері, а безпосередньо у браузері, використовуючи історію переходів та зміну виглядів інтерфейсу без перезавантаження сторінки. Хоча механізм у цьому випадку відрізняється, концепція та сама: певна адреса означає певний стан інтерфейсу, а маршрутизатор відповідає за визначення того, який компонент потрібно завантажити й показати. Це ще раз підтверджує універсальність маршрутизації як концепції.

Якщо підсумувати, маршрутизація — це складний, але надзвичайно важливий механізм, який забезпечує впорядкований рух запитів усередині програми. Вона дозволяє створювати логічну структуру навіть у дуже великих системах, зберігаючи зрозумілість, підтримуваність і масштабованість. Без маршрутизації сучасні застосунки були б хаотичними та складними у керуванні, тоді як добре організована схема маршрутів перетворює навіть величезну систему на впорядковану карту, якою легко користуватися й розвивати.

## Приклад маршрутизації у вигаданому узагальненому MVC-фреймворку

Уявімо умовний MVC-фреймворк із простою декларативною маршрутизацією. Хоча синтаксис у прикладі умовний, він ілюструє загальний принцип, який можна зустріти у багатьох реальних фреймворках

```
routes:
  GET /products -> ProductController@index
  GET /products/{id} -> ProductController@show
  POST /products -> ProductController@create
  PUT /products/{id} -> ProductController@update
  DELETE /products/{id} -> ProductController@delete

  GET /users/login -> UserController@loginForm
  POST /users/login -> UserController@login
  GET /users/profile -> UserController@profile
```

Попри простоту, цей приклад демонструє кілька важливих концепцій маршрутизації.

По-перше, адреси не є фізичними файлами. Це логічні шляхи, які система інтерпретує через маршрутизатор. Кожен маршрут складається з HTTP-методу та шляху. Метод визначає, який тип дії очікується: отримання даних, створення, редагування чи видалення. У свою чергу шлях визначає контекст, тобто логічну область програми.

По-друге, маршрути можуть містити змінні частини — у прикладі це {id}. Маршрутизатор “витягує” цю змінну зі шляху й передає її у відповідний метод контролера як параметр. Так само можуть працювати й складніші правила, наприклад змінні з обмеженнями формату.

По-третє, маршрути прив’язані до конкретних методів контролерів. Наприклад, запит GET /products/20 буде спрямований до методу show класу ProductController, при цьому 20 буде параметром. Це дозволяє будувати поведінку застосунку в стилі "те, що бачить користувач у адресному рядку, визначає, яку частину логіки буде виконано".

Нарешті, у системах з аутентифікацією маршрутизатор може також реагувати на правила доступу. Наприклад, доступ до /users/profile може виконуватися лише після перевірки автентичності. Якщо користувач неавторизований, маршрутизатор може перенаправити його на інший маршрут, наприклад /users/login. Таким чином маршрутизатор виконує роль не тільки механізму навігації, а й першого рівня логіки безпеки.

## Внутрішній алгоритм роботи маршрутизатора

Щоб зрозуміти, як саме застосунок “знаходить” правильний контролер для обробки запиту, необхідно розглянути внутрішню будову маршрутизатора. Попри те, що його реалізація може відрізнятися залежно від мови чи фреймворку, загальні концепції залишаються стабільними. У будь-якій системі маршрутизатор виконує три основні кроки: аналіз шляху, пошук відповідного маршруту та визначення пріоритетів.

Першим етапом є парсинг шляху. Коли сервер отримує запит, маршрутизатор виділяє з нього шлях URL, наприклад /products/view/15. Далі шлях розбивається на сегменти: products, view і 15. Одночасно маршрутизатор отримує метод запиту — GET, POST, PUT або інший, адже часто саме метод визначає, який маршрут буде вважатися правильним. Після розбиття маршрутизатор приводить segments до стандартизованого вигляду: може обрізати зайві слеші, нормалізувати регістр або виконувати URL-декодування. У випадку складніших конфігурацій маршрутизатор також може враховувати параметри рядка запиту або доменні маски, наприклад api.example.com.

Щоб ефективно працювати з великою кількістю маршрутів, більшість сучасних систем використовують дерево маршрутів. Замість того щоб перевіряти кожен маршрут по черзі, маршрутизатор заздалегідь формує дерево, де кожен сегмент URL є окремим вузлом. Наприклад, маршрут /products/view/:id представлено як шлях із трьох вузлів: products → view → :id. Динамічні сегменти, такі як :id, зберігаються як особливі вузли, що можуть відповідати різним значенням. Це дає змогу пошуку пересуватися по дереву з мінімальною кількістю порівнянь: якщо перший сегмент запиту не збігається зі статичним вузлом products, маршрутизатор одразу знає, що шлях не підходить і не витрачає час на всі маршрути, які починаються з інших сегментів.

Після аналізу URL маршрутизатор переходить до вибору найбільш відповідного маршруту. Важливу роль тут відіграють пріоритети. У системах маршрутизації завжди існує правило: чим конкретніший маршрут, тим вищий його пріоритет. Наприклад, статичний маршрут /products/view/all важливіший, ніж /products/view/:id, а той, у свою чергу, важливіший за /products/:action/:id. Маршрутизатор завжди намагається зіставити запит зі статичним шляхом, а вже потім розглядає маршрути з динамічними сегментами. У деяких реалізаціях пріоритети також залежать від методу запиту та наявності умов (наприклад, регулярних виразів для параметрів). Таким чином, маршрутизатор гарантує однозначність вибору та запобігає випадковому зіставленню із надто широкими правилами.

У підсумку процес маршрутизації виглядає як чіткий покроковий алгоритм: спочатку URL нормалізується і розбивається на сегменти, потім маршрутизатор рухається деревом маршрутів, порівнюючи сегменти запиту зі статичними й динамічними вузлами, а у випадку, коли знайдено кілька можливих збігів, система застосовує правила пріоритетів. Результатом усіх цих дій є визначення точного контролера та його методу, а також збір параметрів, які передаються до нього. Завдяки цьому логіка маршрутизації залишається прозорою, швидкою та передбачуваною навіть у дуже великих застосунках.
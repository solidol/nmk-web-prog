# Лекція 8. Організація роботи з СУБД MySQL

[Перелік лекцій](../README.md)

### З'єднання

Значення коду для з'єднання з БД часто недооцінюють, зводячи до однієї стрічки. Однак правильне з'єднання допомагає уникнути багатьох проблем — від неправильного відображення символів до помилкових повідомлень, і навіть впливає на безпеку.

Якщо ваш код написаний на звичайному процедурному PHP, ось приклад простого з'єднання:

```php
$host     = '127.0.0.1';
$db       = 'test';
$user     = 'root';
$password = '';
$port     = 3306;
$charset  = 'utf8mb4';

mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
$db = new mysqli($host, $user, $password, $db, $port);
$db->set_charset($charset);
$db->options(MYSQLI_OPT_INT_AND_FLOAT_NATIVE, 1);
```

### Важливі моменти:
1. **Повідомлення про помилки** — встановлення правильного режиму дозволяє уникнути непонятних помилок і отримувати чіткі повідомлення від MySQL.
2. **Кодування** — правильна установка `charset` позбавить від проблем з кодовими сторінками, як наприклад "крокозябри".
3. **Безпека** — помилки не повинні виводитися в браузер, як це часто показують застарілі посібники.
4. **Типи даних** — налаштування `MYSQLI_OPT_INT_AND_FLOAT_NATIVE` дозволяє повертати коректні типи даних із БД, замість строк.

### Об’єктний і процедурний інтерфейси
Функції в `mysqli` можна викликати як в процедурному стилі, так і в об'єктному. Приклад:
```php
mysqli_query($mysqli, $query); // процедурний
$mysqli->query($query); // об'єктний
```
Я рекомендую використовувати **об'єктний синтаксис**, оскільки він коротший і легший у використанні.

### Підготовлені запити
Один із головних недоліків старого `mysql` розширення — це відсутність підтримки підготовлених запитів, що могло призвести до SQL-ін'єкцій. Використання підготовлених запитів у `mysqli` — обов'язкова практика для безпеки.

Приклад INSERT-запиту:
```php
$stmt = $db->prepare("INSERT INTO users (email, password) VALUES (?,?)");
$stmt->bind_param("ss", $email, $password_hash);
$stmt->execute();
```
Три кроки:
1. Підготовка запиту зі знаками питання (плейсхолдерами).
2. Прив'язка змінних до підготовленого виразу.
3. Виконання запиту.

Приклад підготовленого UPDATE-запиту:
```php
$sql = "UPDATE users SET name=?, email=?, password=? WHERE id=?";
$stmt= $conn->prepare($sql);
$stmt->bind_param("sssi", $name, $email, $password, $id);
$stmt->execute();
```
Зміна перемінних на знаки питання та підготовка до виконання запиту.

### Виконання SELECT через підготовлені вирази
При виконанні SELECT-запитів треба отримати об'єкт результату:
```php
$stmt = $db->prepare("SELECT * FROM users WHERE email = ?");
$stmt->bind_param("s", $email);
$stmt->execute();
$result = $stmt->get_result();
```
Функція `get_result()` повертає об'єкт `mysqli_result`, з якого можна отримати строки в масив або об'єкт.

### Виконання запитів без перемінних
Якщо запит не містить змінних, можна використовувати функцію `query()`:
```php
$menu = $db->query("SELECT * FROM menu")->fetch_all(MYSQLI_ASSOC);
```

### Обробка помилок
Як правило, для запитів не потрібно писати код для обробки помилок вручну. `mysqli` автоматично обробляє помилки завдяки функції `mysqli_report()`, яка забезпечує єдиний підхід до їх обробки.

### Кількість рядків, затронутих запитом
Для отримання кількості затронутих запитом рядків можна використовувати `affected_rows()`:
```php
echo $db->affected_rows();
```

### Підсумок
Використання підготовлених виразів, об'єктного синтаксису та правильних налаштувань безпеки — це основні кроки для створення надійного і безпечного з'єднання з БД через `mysqli`.
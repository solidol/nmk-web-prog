# Лекція 15. Пакетний менеджер Composer

[Перелік лекцій](../README.md)

## Вступ

Composer є стандартним інструментом для керування залежностями в екосистемі PHP. Він дозволяє визначати, встановлювати, оновлювати та контролювати зовнішні бібліотеки, без яких сучасна розробка на PHP була б значно складнішою. Composer автоматизує отримання потрібних пакетів, аналізує їхні взаємні залежності, слідкує за сумісністю версій та створює відтворюване оточення для виконання програмного коду.

Стандартом управління залежностями Composer став завдяки поєднанню простоти, гнучкості та широкої підтримки в спільноті. Усі великі PHP‑фреймворки та більшість популярних бібліотек доступні через Composer, що робить його незамінним у професійних командах.

## Основні можливості Composer

Composer вирішує два фундаментальні завдання. Перше — забезпечення коректної та передбачуваної інсталяції залежностей. Друге — створення механізму, який дозволяє легко контролювати версії, тестувати оновлення та мінімізувати конфлікти пакетів. Його головний конфігураційний файл `composer.json` описує проєкт, а файл `composer.lock` дозволяє відтворити середовище на будь‑якій машині.

Крім того, Composer має командний інтерфейс, яким користуються для встановлення пакетів, оновлення залежностей, генерації автозавантажувача, запуску скриптів, визначених у конфігурації, та перевірки сумісності бібліотек.

## Архітектура Composer

Архітектура Composer складається з кількох логічних рівнів, кожен з яких відповідає за свою частину роботи. Перший рівень — це механізм читання та парсингу конфігураційних файлів, який забезпечує отримання інформації про пакет, залежності, вимоги до PHP та інші параметри. Другий рівень — це система резолюції залежностей, що працює як складний алгоритм пошуку оптимальних сумісних версій. Третій рівень — механізм завантаження, кешування та встановлення пакетів з репозиторіїв.

Над усією системою розташований високорівневий командний інтерфейс, який надає доступ до основних функцій і координує взаємодію між внутрішніми компонентами.

## Репозиторії Composer

Основним публічним репозиторієм є Packagist — великий каталог бібліотек, який дозволяє будь‑якому розробнику публікувати свої пакети. Composer вміє працювати і з приватними репозиторіями, які можуть знаходитися в Git‑сховищах, архівах, локальних каталогах або спеціалізованих корпоративних сервісах.

Репозиторій є джерелом інформації про версії, метадані та залежності. Composer звертається до нього в процесі резолюції залежностей, отримує списки доступних версій та визначає, яким чином вони сумісні з вимогами проєкту.

## Файли configuration: composer.json та composer.lock

Файл `composer.json` описує конфігурацію проекту. У ньому визначаються назва пакету, залежності, вимоги до PHP, тип автозавантаження, скрипти, репозиторії та інші параметри. Цей файл — відправна точка роботи Composer.

Файл `composer.lock` фіксує конкретні версії залежностей, які були встановлені. Це дозволяє гарантувати повторюваність оточення незалежно від часу та зовнішніх оновлень. Іншими словами, два розробники з однією версією `composer.lock` отримають однаковий набір бібліотек.

## Semver і правила версіонування

Composer дотримується концепції семантичного версіонування (semver). Це означає, що версія поділяється на три компоненти — major, minor і patch — і зміни в кожній частині мають своє семантичне значення. Завдяки цьому Composer може визначати, які версії сумісні одна з одною, а які можуть порушити роботу проєкту.

Крім того, Composer підтримує спеціальні нотації для визначення діапазонів версій, такі як `^1.2`, `~2.3`, `>=1.0` або точні фіксації через `1.5.2`. Правила версіонування дозволяють гнучко контролювати оновлення.

## Автозавантаження

Однією з ключових частин Composer є механізм автозавантаження, який працює відповідно до PSR‑4, PSR‑0 і класичного мапінгу. Composer генерує файл автозавантажувача `vendor/autoload.php`, який можна підключити в будь‑якому PHP‑коді для автоматичного підвантаження класів.

Автозавантаження позбавляє необхідності вручну підключати кожен файл, дозволяє структурувати код у просторі імен та підвищує масштабованість системи.

## Механізм резолюції залежностей

Внутрішній алгоритм резолюції залежностей у Composer працює як складний комбінаторний пошук. Він аналізує вимоги всіх пакетів, їх сумісність і можливі конфлікти. На кожному кроці алгоритм перевіряє доступні версії та формує оптимальний набір бібліотек, який відповідає зазначеним обмеженням. У випадку конфлікту він переглядає альтернативні комбінації, доки не буде знайдено рішення або доки не стане очевидно, що сумісний набір знайти неможливо.

Ефективність резолюції залежить від репозиторіїв, кешування та коректності метаданих пакетів.

## Робота з пакетами: встановлення, оновлення, видалення

Composer забезпечує інтуїтивно зрозумілі команди для роботи з залежностями. Встановлення пакетів відбувається шляхом додавання їх у `composer.json` та запуску `composer install`. Оновлення здійснюється командою `composer update`, яка переглядає доступні версії відповідно до правил семантичного версіонування. Видалення пакетів виконується через команду `composer remove`, що також очищує відповідні записи в конфігураційних файлах і перегенерує автозавантажувач.

## Скрипти та автоматизація

Composer дозволяє визначати власні скрипти, які можуть виконуватися перед або після основних команд. Це корисно для запуску тестів, збирання проєкту, очищення кешу чи генерації документації. Система скриптів працює як інтегрований механізм автоматизації в робочих процесах.

## Кешування

Композер активно використовує кеш, щоб зменшити кількість запитів до репозиторіїв і прискорити роботу. Кеш включає метадані, архіви пакетів та різні службові файли. Наявність кешу дозволяє пришвидшити повторні інсталяції та роботу в офлайн‑режимі.



## Порівняння Composer і npm

Пакетні менеджери Composer та npm виконують подібну роль у своїх екосистемах — вони керують залежностями, забезпечують відтворюваність середовища та спрощують життєвий цикл розробки. Проте їхній дизайн, модель роботи та екосистемні особливості значно відрізняються, оскільки вони створені для різних мов програмування й різних типів застосунків.

### Загальна спрямованість екосистем

Composer належить до екосистеми PHP і фокусується переважно на серверних застосунках, включно з веб-фреймворками, бібліотеками бізнес-логіки, ORM-інструментами та іншим бекенд-функціоналом. npm сформувався навколо Node.js, але водночас став стандартом де-факто для фронтенд-розробки. Це означає, що npm обслуговує значно ширший набір сценаріїв — від бекенду до UI-бібліотек, інструментів збірки, транспайлерів та клієнтського JavaScript.

Унаслідок цього npm має набагато більшу кількість пакетів, але й більшу фрагментованість, тоді як Composer і Packagist зберігають більшу структурованість і стабільність.

### Архітектура репозиторіїв

Composer традиційно використовує єдиний централізований репозиторій — Packagist. npm має npm Registry, який теж є основним, але екосистема дозволяє створювати приватні дзеркала й проксі різними інструментами, що часто застосовується у великих командах.

Packagist суворіше контролює оформлення метаданих, підтримку версій та дотримання стандартів, тоді як npm Registry відомий нижчим порогом входу, що сприяє появі величезної кількості пакетів різної якості.

### Модель залежностей і структура директорій

Одна з ключових концептуальних відмінностей полягає в моделі розміщення залежностей.

Composer використовує єдине дерево залежностей у каталозі vendor/. Це означає, що кожен пакет встановлюється в одному екземплярі. Якщо два пакети потребують різних версій однієї бібліотеки, Composer намагається знайти компромісну версію або повідомляє про конфлікт. Така модель забезпечує предбачуваність середовища та спрощує виявлення несумісностей.

npm застосовує вкладену модель залежностей, за якої кожен пакет може мати свою власну копію залежностей у node_modules. Це дозволяє уникати конфліктів між пакетами, але призводить до громіздкої структури, потенційно величезних директорій та дублювання коду. Новіші версії npm (і альтернативи типу pnpm) намагаються оптимізувати це через симлінки й кеш-шару, але концептуально модель лишається іншою.

### Резолюція залежностей

Composer застосовує складну, але сувору модель резолюції залежностей, орієнтовану на семантичну сумісність і наявність єдиного набору бібліотек. npm, натомість, дозволяє легше комбінувати несумісні пакети, оскільки кожен пакет може містити власне дерево залежностей.

У Composer конфлікт означає, що проєкт неможливо зібрати. У npm конфлікт, як правило, локалізується в межах одного пакета і не впливає глобально на застосунок, хоча може спричинити непередбачувану поведінку.

### Автозавантаження та робочий процес із кодом

Composer підтримує автозавантаження відповідно до PSR-стандартів (переважно PSR-4). Це інтегрований механізм, що генерується автоматично. Він дозволяє бібліотекам працювати узгоджено в будь-якому проєкті.

npm не має центрального механізму автозавантаження, оскільки екосистема JavaScript ґрунтується на нативному імпорті модулів (CommonJS, ESM). Це робить модульність прозорішою, але перекладає відповідальність за структурування коду на розробника або інструменти збірки.

### Скрипти й автоматизація

Обидва менеджери мають можливість запускати скрипти.

Composer дозволяє визначати подієві скрипти, які виконуються перед або після певних команд, що робить його схожим на міні-CI для PHP-проєктів.

npm використовує поле "scripts" як універсальну точку для запуску команд, що включають інструменти збірки, тестування, лінтери тощо. Через це npm часто виступає центром усього DevOps-ланцюжка фронтенд-розробки.

Наслідок: npm-скрипти є набагато ширше застосовуваними та часто складнішими.

### Проблеми безпеки та аудит залежностей

npm має історію проблем через надлишок дрібних пакетів, відсутність суворих стандартів на початку розвитку та можливість публікувати пакети з мінімальним контролем. Тому інструменти типу npm audit стали необхідністю.

Composer традиційно працює зі значно більш крупними і структурованими пакетами. Інцидентів значно менше, а Packagist має більш зрілу систему перевірки метаданих. Існують інструменти безпеки (наприклад, інтеграція з security-advisories), але масштаб проблемності в екосистемі менший.

### Швидкість роботи та кешування

npm має складну історію продуктивності, що призвело до появи альтернатив: yarn, pnpm, bun. Composer також мав проблеми з продуктивністю на ранніх етапах, але сучасні версії працюють стабільно і досить швидко за рахунок агресивного кешування.

npm оперує значно більшим числом пакетів і складнішими залежностями інструментів збірки, що ускладнює оптимізацію.

## Висновок

Composer є фундаментальним інструментом сучасного PHP‑розробника. Його архітектура, підтримка семантичного версіонування, можливість використання публічних і приватних репозиторіїв, система автозавантаження та інструменти автоматизації створюють гнучке та потужне середовище для створення масштабованих програмних рішень. Розуміння принципів роботи Composer, його внутрішніх механізмів і кращих практик використання є необхідною складовою професійної підготовки в області веб‑розробки.

Попри схожість базових принципів, Composer і npm є продуктами своїх екосистем і розв’язують різні архітектурні завдання. Composer пропонує сувору модель залежностей та централізованість, що підходить для стабільних бекенд-проєктів. npm забезпечує гнучкість і швидкість, необхідні у швидкоплинному світі фронтенду, де важливо підтримувати широкий набір інструментів.
# Лекція 4. Робота з функція у мові РНР. Створення користувацьких функцій

[Перелік лекцій](../README.md)

## Оголошення та виклик функції
Для оголошення функції необхідно скористатися ключовим словом Function, після якого слідує ім’я функції, у круглих дужках параметри та у фігурних дужках тіло:

```php
function myFunction()
{
    // Оператори
}
```

> Стандарт кодування PSR рекомендує ім’я функції задавати в camelCase-стилі з першою малою літерою, щоб відрізняти функції від класів.
Функція може повертати значення. Для цього необхідно використовувати конструкцію return:

```php
function myFunction()
{
    // Оператори
    return 0;
}
```

Продемонструємо приклад, де функція обчислює суму двох чисел:

```php
<?php
function getSum()
{
    $sum = 1 + 2;
    return $sum;
}
echo getSum(); // 3
```

У цьому прикладі функція не приймає жодного аргументу, а просто обчислює суму та повертає отриманий результат. Після цього вона викликається у тілі конструкції Echo для виведення результату у браузер. Можна змінити функцію так, щоб вивід здійснювався виключно в тілі функції, для цього необхідно змінити конструкцію return на echo. Однак такий підхід зазвичай не вітається, тобто сильно звужує область застосування функції, оскільки рядок, що повертається, неможливо буде передати далі для обробки іншим функціям.

Функція може викликатись до її оголошення, за винятком тих випадків, якщо оголошення функції здійснюється залежно від умови усередині фігурних дужок. У цьому випадку спроба виклику функції, оголошеної раніше оголошення функції призводить до помилки: "Fatal error: Uncaught Error: Call to undefined function".

## Параметри та аргументи функції

Використовуючи параметри функції можна значно збільшити її гнучкість:

```php
<?php
function getSum($a, $b)
{
    $sum = $a + $b;
    return $sum;
}
echo getSum(1, 2); // 3
```

Змінні $a та $b, які задаються у круглих дужках під час оголошення, називаються параметрами функції. При виклику функції замість них можуть бути підставлені змінні з іншими назвами або просто значення, які називаються аргументами. Як аргументи можуть виступати висловлювання і навіть інші функції.

## Типи параметрів та значення результату виконання

Дозволяється при оголошенні функції вказувати типи параметрів. Якщо необхідно задати тип значення результату виконання, він вказується через двокрапку безпосередньо перед тілом функції:

```php
<?php
function getSum(int $a, int $b) : int
{
    return $a + $b;
}
echo getSum(1, 2); // 3
echo getSum(1.5, 2.5); // 3
```

## Передача параметрів за значенням та посиланням
За замовчуванням параметри функції змінюються лише всередині функції і ці зміни не впливають на значення змінних за межами функції.

```php
<?php
function getSum($var) // аргумент передається за значенням
{
    $var = $var + 5;
    return $var;
}
$new_var = 10;
echo getSum($new_var); // 15
echo $new_var; // 10
```

Для того, щоб змінні, передані функції, зберігали своє значення при виході з неї, застосовується передача параметрів за посиланням. Для цього перед ім’ям змінної необхідно помістити амперсанд (&):

```php
function get_sum(&$var)
```

Об’єкти та масиви передаються у функцію за посиланням, тому стосовно таких параметрів можна не застосовувати символ амперсанда (&).

```php
<?php
function getSum(&$var) // аргумент передається за значенням
{
    $var = $var + 5;
    return $var;
}
$new_var = 10;
echo getSum($new_var); // 15
echo $new_var; // 15
```

## Необов’язкові параметри
Якщо налаштувати параметри за замовчуванням, то вони не є необов’язковими.

```php
<?php
function getSum($a = 1, $b = 2)
{
    $sum = $a + $b;
    return $sum;
}
echo getSum(); // 3
echo getSum(2); // 4
echo getSum(2, 3); // 5
```

З прикладу видно, що навіть якщо функції getSum() не передаються аргументи, вона успішно здійснює обчислення за участю параметрів за замовчуванням. Якщо функція містить безліч обов’язкових і необов’язкових параметрів, всі обов’язкові параметри слід розташовувати до необов’язкових, інакше буде виведена помилка: "Fatal error: Uncaught ArgumentCountError: Too few arguments to function".

## Змінна кількість параметрів

Щоб створити функцію, яка приймає змінну кількість аргументів, перед останнім параметром слід вказати трикрапку. Усередині функції такий параметр розглядається як масив, що містить усі додаткові параметри:

```php
<?php
function echoList(...$items)
{
    foreach ($items as $value) {
        echo $value; // выводим элемент
    }
}
echoList('red', 'green', 'yellow'); // red green yellow
```

До версії 5.6 РНР не підтримував описуваний механізм обробки змінної кількості параметрів. Натомість використовувалися функції Func_num_args, Func_get_arg та Func_get_args.

Оператор ... може використовуватися не тільки перед аргументами функцій, але й при виклику з масивом. Це дозволяє здійснити «розгортання» масиву:

```php
<?php
function tooManyArgs($a, $b, $c)
{
    echo "Перший параметр: $a";
    echo "Другий параметр: $b";
    echo "Третій параметр: $c";
}
$items = ['red', 'yellow', 'green'];
tooManyArgs(...$items);
```

Як видно з прикладу, можна помістити значення параметрів у масив $items і передати його функції, випередивши оператором ..., який розгорне елементи масиву у відповідні параметри:

Перший параметр: red

Другий параметр: yellow

Третій параметр: green

## Глобальні змінні

Змінні функції мають локальну область видимості. Це означає, що навіть якщо локальна (всередині функції) і зовнішня (поза функцією) змінні мають однакові імена, то локальна змінна ніяк не вплине на зовнішню змінну. Локальну змінну можна зробити зовнішньою, якщо перед ім’ям вказати ключове слово global. У цьому випадку зміни як усередині функції, так і поза нею впливатимуть на змінну, а сама змінна називатиметься глобальною. Якщо локальна змінна оголошена як global, то до неї можливий доступ із будь-якої частини програми:

```php
<?php
function getSum()
{
    global $a;
    $a = 1; // Змінюємо глобальну змінну
    return $a;
}
$a = 5;
echo $a;       // виводить 5
echo getSum(); // виводить 1 (глобальна змінна змінена)
echo $a;       // виводить 1
```

## Статичні змінні
Оскільки локальні змінні мають своєю областю видимості функцію, час життя локальної змінної визначається часом виконання функції, у якій вона оголошена. Це означає, що у різних функціях абсолютно незалежно друг від друга можна використовувати змінні з однаковими іменами. Локальна змінна при кожному виклик функції ініціалізується заново, тому функція-лічильник завжди буде повертати значення 1:

```php
<?php
function counter()
{
    $counter = 0;
    return ++$counter;
}
```

Для того, щоб локальна змінна зберігала своє попереднє значення при нових викликах функції, її можна оголосити статичною за допомогою ключового слова static:

```php
<?php
function counter()
{
    static $counter = 0;
    return ++$counter;
}
```

У прикладі, змінна $counter встановлюється в нуль за першого виклику функції, і при наступних викликах функція запам’ятає, яким було значення змінної при попередніх викликах.

Часом життя статичних та глобальних змінних є час виконання сценарію. Тобто, якщо користувач перезавантажує сторінку, що призводить до нового виконання сценарію, змінна $counter ініціалізується заново.

## Повернення масиву функцією

Якщо передати конструкції return масив, то функція поверне масив як значення. Більш того, такий масив може створюватись динамічно за допомогою конструкції array() або []. До цього прийому вдаються щоразу, коли функція повинна повернути кілька значень, а передача значень по посиланню не допускається. Продемонструємо приклад, в якому функція приймає як значення розмір файлу в байтах і повертає масив, перший елемент якого містить розмір в байтах, другий - в кілобайтах, третій - в мегабайтах, а четвертий - в гігабайтах.

```php
<?php
function formatSize($bytes)
{
    $kbytes = $bytes / 1024;
    $mbytes = $kbytes / 1024;
    $gbytes = $mbytes / 1024;
    return [$bytes, $kbytes, $mbytes, $gbytes];
}
list($bytes, $kbytes, $mbytes, $gbytes) = formatSize(45678921);
```

Якщо масив має постійну невелику кількість елементів, то оперувати їм у скрипті не завжди зручно. Тому часто при виклик функції елементи масиву відразу ж зіставляються змінним за допомогою конструкції List, що продемонстровано в попередньому прикладі.

## Рекурсивні функції

Рекурсія – це виклик функцією самої себе. Наведемо приклад рекурсивної функції:

```php
<?php
function callself($counter)
{
    if ($counter > 0) {
        echo $counter--;
        callself($counter);
    }
    else return;
}
callself(5);
```

Результатом роботи функції буде послідовність цифр: 54321. Функція викликає саму себе доти, доки її параметр $counter додатній і не дорівнює нулю. Оскільки рекурсивні функції відносяться до важких для сприйняття конструкцій мови, їх по можливості намагаються уникати. Небезпека використання неналагоджених рекурсивних функцій полягає у можливості їхнього зависання, тобто переходу в режим нескінченної рекурсії.

Майже в будь-якому випадку можна уникнути рекурсивних функцій. Винятком є ​​завдання, так чи інакше пов’язані з обходом дерев. До таких завдань відноситься, наприклад, видалення каталогів, коли число файлів і підкаталогів заздалегідь невідоме, і необхідно викликати функцію видалення доти, доки не будуть видалені файли на найглибшому рівні вкладеності.

У РНР можна оголошувати функції всередині іншої функції. На відміну від звичайних функцій, вкладена функція не може використовуватися доти, доки не буде здійснено виклик основної функції.

## Динамічне ім’я функції

За аналогією зі змінними, ім’я функції може бути динамічним і зберігатись у рядковій змінній - передача такої змінної оператором круглих дужок (з параметрами, якщо вони потрібні) призводить до виклику функції:

```php
<?php
function str()
{
    return 'Hello, World!';
}
$var = 'str';
echo $var(); // Hello, World!
```

## Анонімні функції
Анонімні функції – це функції без імені:

```php
<?php
$echoList = function (...$str)
{
    foreach ($str as $value) {
        echo $value;
    }
};
// Виклик функції
$echoList('red', 'yellow', 'green'); // red yellow green
```

## Замикання
Замикання – це функція, яка запам’ятовує стан оточення у момент свого створення. Навіть якщо стан змінюється, замикання містить початковий стан. Для активізації необхідно використовувати ключове слово use, а за ним у дужках можна вказати змінні, які мають увійти до замикання:

```php
<?php
$message = 'First';
$check = function(array $errors) use ($message)
{
    if (isset($errors) && count($errors) > 0) {
        echo $message;
        foreach($errors as $error) {
            echo $error;
        }
    }
};
$check([]); // First
$erorrs[] = 'Second';
$check($erorrs); 
$message = 'Third';
$erorrs = ['Fourth', 'Fifth', 'Sixth'];
$check($erorrs);
```

У прикладі створюється анонімна функція-замикання, яка міститься в змінній $check, за допомогою ключового слова use замикання захоплює змінну $message, яку використовує у своїй роботі. Спроба змінити значення змінної пізніше не призводить до результату. Замикання «пам’ятає» стан змінної на момент свого створення. Результатом виконання скрипта будуть наступні рядки:

First

Second

First

Fourth

Fifth

Sixth

Основне призначення замикань – заміна глобальних змінних. На відміну від глобальних змінних, ви можете передати в середину функції значення, але вже не зможете змінити змінну, передану через механізм замикання. Найголовніше – жодні зміни глобальної змінної в інших частинах програми не зможуть вплинути на значення, передане через замикання.